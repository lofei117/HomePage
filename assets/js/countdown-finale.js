/**
 * @preserve Homepage countdown finale experience.
 * This file includes all functionality to render the countdown
 * finale. Depends on Tween.js, Three.js libraries and base.js.
 *
 * Vendor provided code. Compressed file for the live site,
 * this raw script at http://closure-compiler.appspot.com/ using the
 * default, "simple," optimization setting.
 *
 * @author mking@mking.me (Matt King)
 */

/**
 * Color palette used in shapes. Three.js requires colors to be in decimal form.
 */
var colors = [0x265897, 0x13acfa, 0x009a49, 0xc0000b, 0xa1cb50, 0xB11B23,
              0xFDD901, 0x222222, 0xE44D26, 0x70A3D6, 0x9DC3E6, 0xAAAAAA,
              0xCCCCCC, 0xEEEEEE];

/**
 * Encoded entity positions generated by the countdown builder.
 * Includes information about the grid size and increments, which allows for
 * larger or smaller grids per shape.
 */

/**
 * We use Math.PI * 2 a lot when drawing the dots, so we store it here.
 */
var PI2 = Math.PI * 2;

/**
 * Class CountdownMaterial
 * A wrapper around the Three.js ParticleCanvasMaterial.
 * @param {Object} opts Settings for CountdownMaterial.
 * @param {Object} opts.color color value for material.
 * @param {Function} opts.program function used to draw material.
 */
function CountdownMaterial(opts) {
  this.color = opts.color;
  if (opts.program) {
    this.program = opts.program;
  }
  this.material = new THREE.ParticleCanvasMaterial({
    color: this.color,
    program: this.program
  });
}

/**
 * Default function used to draw a dot.
 * @param {Object} ctx Canvas context to draw on.
 */
CountdownMaterial.prototype.program = function(ctx) {
  ctx.beginPath();
  ctx.arc(0, 0, 1, 0, PI2, true);
  ctx.closePath();
  ctx.fill();
};

/**
 * Class CountdownParticle
 * A wrapper around the Three.js Particle.
 * @param {Object} opts Settings for CountdownParticle.
 * @param {THREE.ParticleCanvasMaterial} opts.material material used
 *     in the THREE.Particle
 * @param {Number} opts.x Positional x value.
 * @param {Number} opts.y Positional y value.
 * @param {Number} opts.z Positional z value.
 * @param {Number} opts.scale Scale of the particle.
 * @param {Number} opts.delay Delay at which the Tween starts when
 *     the splode function is called.
 */
function CountdownParticle(opts) {
  for (k in opts) {
    this[k] = opts[k];
  }
  this.z = (opts.z || 0);
  this.material = opts.material;
  this.particle = new THREE.Particle(this.material);
  this.particle.position.x = (opts.x || 0);
  this.particle.position.y = (opts.y || 0);
  this.particle.position.z = (opts.z || 0);
  this.particle.scale.x = this.particle.scale.y = (opts.scale || 1);
  this.delay = (opts.delay || 0);
}

/**
 * Change the position of the Particle by using the TWEEN library.
 * Generates a random x, y and z position and fires off a call
 * to the TWEEN.Tween function. On complete, it fires off the
 * afterSplode function on the entity if it hasn't been called already.
 */
CountdownParticle.prototype.splode = function() {
  var self = this;
  var splodeTo = {x: (Math.random() * 2500) - 1250,
                  y: (Math.random() * 2500) - 1250,
                  z: (Math.random() * 6500) - 5500};
  new TWEEN.Tween(this.particle.position)
    .delay(this.delay)
    .to(splodeTo, 2000)
    .easing(TWEEN.Easing.Exponential.EaseOut)
    .onComplete(function() {
      if (self.particle.position.z < -2000) {
        self.exit.call(self);
      }
      if (!self.entity.calledAfterSplode) {
        self.entity.afterSplode.call(self);
        self.entity.calledAfterSplode = true;
      }
    }).start();
};

/**
 * Change the position of the Particle by using the TWEEN library.
 * Resets the Particle back to it's origin x, y, and z coordinates.
 */
CountdownParticle.prototype.implode = function() {
  new TWEEN.Tween(this.particle.position)
    .delay(Math.random()*300)
    .to({x: this.originX, y: this.originY, z: this.originZ}, 1000)
    .easing(TWEEN.Easing.Circular.EaseOut)
    .start();
};

/**
 * Make the Particle exit the scene using the TWEEN library.
 * Adds to the z position value, then on complete, reduces the
 * associated entity's particle count and fires off the
 * entity's afterExit callback once the particle count reaches zero.
 */
CountdownParticle.prototype.exit = function() {
  var self = this;
  new TWEEN.Tween(this.particle.scale)
    .delay(this.delay)
    .to({x: 0, y: 0}, 1000)
    .easing(TWEEN.Easing.Circular.EaseIn)
    .onComplete(function() {
      self.entity.group.removeChild(self.particle);
      self.entity.particleLength--;
      if (self.entity.particleLength === 0) {
        self.entity.afterExit();
      }
    }).start();
};

/**
 * Class CountdownEntity
 * Manages state of a countdown shape, holding references
 * to CountdownMaterials and CountdownParticles.
 * Calls the build function on initialization.
 * @param {Object} opts Settings for CountdownEntity.
 * @param {Boolean} opts.first If set to true, will render
 *     the entity in it's formed state instead of the implosion
 *     transition.
 * @param {THREE.Object3D} opts.group Group of Three.js objects to
 *     manipulate.
 * @param {Object} opts.entity The positional coordinates
 *     which to place particles at.
 * @param {Function} opts.afterSplode callback to run after the splode
 *     function is complete
 * @param {Function} opts.afterExit callback to run after the exit
 *     function is complete
 */
function CountdownEntity(opts) {
  this.first = opts.first;
  this.group = opts.group;
  this.entity = opts.entity;
  this.materials = [];
  this.particles = [];
  this.particleLength = 0;
  this.afterSplode = (opts.afterSplode || function() {});
  this.afterExit = (opts.afterExit || function() {});
  this.build();
}

/**
 * Add a CountdownParticle to the particles list.
 * Also sets the associated entity of the particle
 * so it can reference callbacks.
 * Adds the CountdownParticle's THREE.Particle to the
 * group so Three.js can render it.
 */
CountdownEntity.prototype.addParticle = function(p) {
  this.particles.push(p);
  p.entity = this;
  this.group.addChild(p.particle);
  this.particleLength++;
};

/**
 * Run through each particle in the particles list
 * and call the splode function on it.
 */
CountdownEntity.prototype.splode = function() {
  for (var i = 0; i < this.particleLength; i++) {
    this.particles[i].splode();
  }
};

/**
 * Run through each particle in the particles list
 * and call the implode function on it.
 */
CountdownEntity.prototype.implode = function() {
  for (var i = 0; i < this.particleLength; i++) {
    this.particles[i].implode();
  }
};

/**
 * Run through each particle in the particles list
 * and call the exit function on it.
 */
CountdownEntity.prototype.exit = function() {
  for (var i = 0; i < this.particleLength; i++) {
    this.particles[i].exit.call(this.particles[i]);
  }
};

/**
 * Takes the entity object and runs through it adding
 * CountdownParticles from the values.
 * Will randomly set the current x, y and z values of the particle
 * unless the first attribute is true, which will make it use the
 * particle's intended coordinates that form the shape.
 * Calls implode to start the transition to form the shape.
 */
CountdownEntity.prototype.build = function() {
  this.gridSize = this.entity.grid.incr * this.entity.grid.size;
  for (var i = 0; i < colors.length; i++) {
    this.materials.push(new CountdownMaterial({ color: colors[i] }));
  }
  for (var i = 0; i < this.entity.dots.length; i++) {
    var vals = this.entity.dots[i];
    var x = parseInt(vals[0], 10);
    var y = parseInt(vals[1], 10);
    var c = parseInt(vals[2], 10);
    if (this.first) {
      var temp = {x: (x * this.entity.grid.incr) - this.gridSize / 2,
                  y: ((y * this.entity.grid.incr) * -1) + this.gridSize / 2,
                  z: 0};
    } else {
      var temp = {x: (Math.random() * 2500) - 1250,
                  y: (Math.random() * 2500) - 1250,
                  z: (Math.random() * 3000) - 1500};
    }
    this.addParticle(new CountdownParticle({
      originX: (x * this.entity.grid.incr) - this.gridSize / 2,
      originY: ((y * this.entity.grid.incr) * -1) + this.gridSize / 2,
      originZ: 0,
      x: temp.x,
      y: temp.y,
      z: temp.z,
      scale: 7,
      material: this.materials[c].material,
      delay: 0,
      entity: this
    }));
  }
  this.implode();
};

/**
 * Wrapper around control functions that run the transitions.
 */
var countdownFinale = (function() {

  /**
   * Store if we've initialized or not. Used when creating a
   * CountdownEntity to determine if it's the first one, which
   * forces it to draw it's shape without imploding.
   */
  var initialized = false;

  /**
   * Variable to hold the swap timeout, in case someone clicks
   * we clear the timeout for the next splode.
   */
  var swapTimeout;

  /**
   * Variables used for DOM elements.
   */
  var container, stats, debug;

  /**
   * Variables used for Three.js scene.
   */
  var camera, scene, renderer;

  /**
   * Variables used to track mouse movement, used to adjust
   * camera and rotation values of the Three.js scene.
   */
  var mouseX = 0, mouseY = 0, mouseXOnMouseDown = 0;
  var targetRotationOnMouseDown = 0, targetRotation = 0;

  /**
   * Store the center X and Y of the window. Used when adjusting
   * the camera and rotation to make it appear to use the center of
   * the window as the point of reference.
   */
  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  /**
   * To simulate camera easing, the factor to multiply the camera
   * position when the mouse is moved.
   */
  var positionAdjustment = 0.02;
  var mouseAdjustment = 1;

  /**
   * Variables to track entity coordinate objects.
   */
  var entities = [], currentEntityDesign = 0;

  /**
   * Called in a loop using requestAnimationFrame, then calling
   * the render function and updating the stats area.
   */
  function animate() {
    requestAnimationFrame(animate);
    render();
    if (stats) {
      stats.update();
    }
  }

  /**
   * Update the scene, adjusting the camera, updating any TWEEN transitions,
   * and render the scene as it's currently set up.
   */
  function render() {
    TWEEN.update();
    camera.position.x += ( mouseX - camera.position.x ) * positionAdjustment;
    camera.position.y += ( - mouseY - camera.position.y ) * positionAdjustment;
    renderer.render(scene, camera);
  }

  /**
   * Track the mouse movements and adjust mouseX and mouseY, in turn
   * updating the camera angle when render is called.
   * @param {Event} e
   */
  function onDocumentMouseMove(e) {
    mouseX = (e.clientX - windowHalfX) / mouseAdjustment;
    mouseY = (e.clientY - windowHalfY) / mouseAdjustment;
  }

  /**
   * Allow the user to rotate and adjust camera zoom with arrow keys.
   * Will call splodeEntity when enter key is pressed.
   * @param {Event} e
   */
  function onDocumentKeyDown(e) {
    switch (e.keyCode) {
     case 37:
      targetRotation -= 0.05;
      break;
     case 38:
      camera.position.z -= 1;
      break;
     case 39:
      targetRotation += 0.05;
      break;
     case 40:
      camera.position.z += 1;
      break;
     case 13:
      onDocumentClick();
      break;
     case 67:
      camera.position.x -= 1;
      break;
     case 85:
      camera.position.y -= 1;
      break;
     case 88:
      camera.position.x += 1;
      break;
     case 89:
      camera.position.y += 1;
      break;
    default:
      break;
    }
  }

  /**
   * Call splodeEntity if the user clicks anywhere on the window.
   * @param {Event} e
   */
  function onDocumentClick(e) {
    if (swapTimeout) {
      swapTimeout.stop();
      entities[0].exit();
    }
    splodeEntity();
  }

  /**
   * Generate a new Three.Object3D, and attach a new CountdownEntity
   * to it. Push the new entity onto the list of entities so we can
   * process them further. Adds group to the Three.js scene.
   * Sets afterSplode callback to the swapEntity function, and afterExit
   * to the removeEntity function.
   */
  function showEntity() {
    var group = new THREE.Object3D();
    var e = new CountdownEntity({
      group: group,
      entity: entityDesigns[currentEntityDesign],
      afterSplode: swapEntity,
      afterExit: removeEntity,
      first: !initialized
    });
    entities.push(e);
    scene.addObject(e.group);
    initialized = true;
  }

  /**
   * Call the splode function on the last item in the entities list.
   */
  function splodeEntity() {
    new TWEEN.Tween(camera.position)
      .delay(0)
      .to({x: camera.position.x+((Math.random()*1200)-600),
           y: camera.position.y+((Math.random()*1200)-600),
           z: camera.position.z-((Math.random()*100)-50)}, 400)
      .easing(TWEEN.Easing.Circular.EaseIn).start();
    entities[entities.length-1].splode();
  }

  /**
   * Take the first entity in the entities list out and remove it
   * from the scene, only if there are two items in the list.
   * Effectively keeps only two shapes on the scene at a time.
   */
  function removeEntity() {
    if (entities.length == 2) {
      var oldGroup = entities.shift();
      scene.removeObject(oldGroup.group);
      oldGroup = null;
    }
  }

  /**
   * Make the first item in the entities list exit, point to the next
   * entity in the entityDesigns list, then call showEntity to transition
   * the new shape in.
   */
  var direction = -1;
  function swapEntity() {
    currentEntityDesign++;
    showEntity();
    if (currentEntityDesign + 1 != entityDesigns.length) {
      if (camera.position.z < 800) {
        direction = 1;
      } else if (camera.position.z > 1000) {
        direction = -1;
      }
      swapTimeout = new TWEEN.Tween(camera.position)
        .to({z: camera.position.z+(200*direction)}, 4000)
        .onComplete(function() {
          entities[0].exit();
          splodeEntity();
        }).easing(TWEEN.Easing.Circular.EaseIn).start();
    }
  }

  /**
   * Set up the DOM container that will hold the Three.js scene, then initialize
   * the Three.js camera, scene and renderer. Also sets up event listeners for
   * mouse movement and keystrokes.
   * Finally fires off animate to star the loop.
   */
  function init() {

    /**
     * Set the container to fill the window.
     */
    container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.top = '0';
    container.style.left = '0';
    container.style.bottom = '0';
    container.style.right = '0';
    container.style.zIndex = '9999';
    document.body.appendChild(container);

    /**
     * Set up the camera.
     */
    camera = new THREE.Camera(75, window.innerWidth / window.innerHeight,
                              0, 2000);
    camera.position.z = 700;

    /**
     * Create the new scene.
     */
    scene = new THREE.Scene();

    /**
     * Fire off the first entity.
     */
    showEntity();

    /**
     * Set up the renderer.
     */
    renderer = new THREE.CanvasRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);

    /**
     * Uncomment to show framerate stats.
     */
    if (window.Stats) {
      stats = new Stats();
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.top = '0px';
      container.appendChild(stats.domElement);
    }

    /**
     * Add the canvas to the container generated by the renderer.
     */
    container.appendChild(renderer.domElement);

    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('keydown', onDocumentKeyDown, false);
    document.addEventListener('click', onDocumentClick, false);

    splodeEntity();

    /**
     * Fire off the animate loop.
     */
    animate();
  }

  return {
    init: init
  };

}());

countdownFinale.init();